\ ==== Boot Block ==============================================
-1 loaded !














; ==== Short Help ==============================================
This is a subroutine threaded Forth, based on eForth. The
starting base in in hexadecimal. A tutorial, word glossary and
extra code is stored in block storage. A short list of commands
follows ('#' are numbers):

  words       list all Forth words
  see         decompile the next word in the input stream
  # #2 index  get descriptive titles for blocks from '#' to '#2'
  # list      list block number '#'
  # load      execute code in block '#'
  # #2 thru   execute code in blocks '#' to '#2'




; ==== Forth Error Messages: 1/4 ===============================
  -1 ABORT
  -2 ABORT"
  -3 stack overflow
  -4 stack underflow
  -5 return stack overflow
  -6 return stack underflow
  -7 do-loops nested too deeply during execution
  -8 dictionary overflow
  -9 invalid memory address
 -10 division by zero
 -11 result out of range
 -12 argument type mismatch
 -13 undefined word
 -14 interpreting a compile-only word
 -15 invalid FORGET
; ==== Forth Error Messages: 2/4 ===============================
 -16 attempt to use zero-length string as a name
 -17 pictured numeric output string overflow
 -18 parsed string overflow
 -19 definition name too long
 -20 write to a read-only location
 -21 unsupported operation
 -22 control structure mismatch
 -23 address alignment exception
 -24 invalid numeric argument
 -25 return stack imbalance
 -26 loop parameters unavailable
 -27 invalid recursion
 -28 user interrupt
 -29 compiler nesting
 -30 obsolescent feature
; ==== Forth Error Messages: 3/4 ===============================
 -31 >BODY used on non-CREATEd definition
 -32 invalid name argument (e.g., TO xxx)
 -33 block read exception
 -34 block write exception
 -35 invalid block number
 -36 invalid file position
 -37 file I/O exception
 -38 non-existent file
 -39 unexpected end of file
 -40 invalid BASE for floating point conversion
 -41 loss of precision
 -42 floating-point divide by zero
 -43 floating-point result out of range
 -44 floating-point stack overflow
 -45 floating-point stack underflow
; ==== Forth Error Messages: 4/4 ===============================
 -46 floating-point invalid argument
 -47 compilation word list deleted
 -48 invalid POSTPONE
 -49 search-order overflow
 -50 search-order underflow
 -51 compilation word list changed
 -52 control-flow stack overflow
 -53 exception stack overflow
 -54 floating-point underflow
 -55 floating-point unidentified fault
 -56 QUIT
 -57 exception in sending or receiving a character
 -58 [IF], [ELSE], or [THEN] exception


; ==== Description of this file ================================
The next screens contain extra code that can be loaded into the
interpreter if needed. Some of the standard Forth words are
placed here instead of in the image to save on space.

The blocks should be loaded in order unless otherwise stated.

This file is first converted by a utility into a fixed width
format, which can then be loaded onto the target board with
the same utility used to uploaded the bitfile to the FPGA.

Form feeds are used to mark the boundaries between blocks,
this does not have any special significance and is only there
to make editing easier. Line lengths are limited to 64
characters wide, each block contains 16 lines.

; ==== Scratch Block ===========================================















\ ==== Assembler word set ======================================
variable assembler-voc
bl parse rdrop pad pack$ find drop assembler-voc !
: assembler assembler-voc 1 set-order ;
: ;code assembler ; immediate
: code [compile] : assembler ;
get-order assembler-voc swap 1+ set-order
: end-code forth [compile] ; ; immediate
: words words ;
: forth forth ;
forth





\ ==== CORDIC 1/2 ==============================================
variable lookup -1 cells allot ( 16 values )
$3243 , $1DAC , $0FAD , $07F5 , $03FE , $01FF , $00FF , $007F ,
$003F , $001F , $000F , $0007 , $0003 , $0001 , $0000 , $0000 ,

: arshift ( n u -- n : arithmetic right shift )
  2dup rshift >r swap $8000 and
  if $10 swap - -1 swap lshift else drop 0 then r> or ;

$26DD constant cordic_1K $6487 constant pi/2

variable tx 0 tx ! variable ty 0 ty ! variable tz 0 tz !
variable x  0  x ! variable y  0  y ! variable z  0  z !
variable d  0  d ! variable k  0  k !


\ ==== CORDIC 2/2 ==============================================
( CORDIC: valid in range -pi/2 to pi/2, arguments are in fixed )
( point format with 1 = 16384, angle is given in radians.  )
: cordic ( angle -- sine cosine )
  z ! cordic_1K x ! 0 y ! 0 k !
  $10 begin ?dup while
    z @ 0< d !
    x @ y @ k @ arshift d @ xor d @ - - tx !
    y @ x @ k @ arshift d @ xor d @ - + ty !
    z @ k @ cells lookup + @ d @ xor d @ - - tz !
    tx @ x ! ty @ y ! tz @ z !
    k 1+!
    1-
  repeat y @ x @ ;
: sin cordic drop ;
: cos cordic nip ;
\ ==== Login Code 1/2 ==========================================
\ Login and user management system: @todo clear up with vocabs
: generate count dup >r crc r> ccitt ; ( b -- u )
: .user     ." user>" space ; ( -- )
: .password ." password>" space ; ( -- )
variable user0 0 user0 !
: mk.user ( --; <string1>, <string2> )
  here user0 @ , user0 ! here 0 , bl word count 1+ allot align
  drop bl word generate swap ! ;
: ls.user ( -- : list all users in user database )
  cr user0 @
  begin dup while dup 2 cells + space count type cr @ repeat
  drop cr ;
: find.user ( a -- u | 0 : find user in database, return hash )
  >r user0 @ begin dup while dup 2 cells + count r@ count
  =string if rdrop exit then @ repeat rdrop drop 0 ;
\ ==== Login Code 2/2 ==========================================
: (password) ( u --, <string> )
  >r begin .password query bl word cr generate
  r@ = until rdrop ;
: fake .password query bl word drop cr ;
: (user)
  begin .user query bl word cr find.user ?dup until ;
: retry ( xt -- : retry word until it succeeds )
  >r begin r@ catch 0= until rdrop ;
: user?     ' (user)     retry ;
: password? ' (password) retry ;
: hide-all 0 1 set-order ;
: login hide-all
  cr user? cell+ @ conceal password? interactive forth ;
mk.user guest guest     mk.user archer dangerzone
mk.user lana  sterling  mk.user cyril  figgis
\ ==== Extra Code 1/7 ==========================================
: 2+ 2 + ;                       ( n -- n )
: 2- 2 - ;                       ( n -- n )
: >= < invert ;                  ( n n -- f )
: simulation? cpu-id $cafe <> ; ( -- f : are we in the matrix? )
: 0<= 0> 0= ;                    ( n n -- f )
: 0>= 0< 0= ;                    ( n n -- f )
: not -1 xor ;                   ( n -- n )
: dabs dup 0< if dnegate then ;  ( d -- d )
: d+  >r swap >r um+ r> r> + + ; ( d d -- d )
: d=  >r swap r> = >r = r> and ; ( d d -- f )
: d<> d= 0= ;                    ( d d -- f )
: roll  dup 0> if swap >r 1- recurse r> swap else drop then ;
: ?exit if rdrop then ;          ( n --, R: n -- n | )
: 2rdrop r> rdrop rdrop >r ;     ( R n n -- )
: 2. swap . . ;                  ( n n -- )
\ ==== Extra Code 2/7 ==========================================

: buffer block ; ( k -- a )
: bye [ 0 , ] ;
: enum dup constant 1+ ; ( n --, <string> )
: logical 0= 0= ;     ( n -- f )
\ ==== Extra Code 3/7 ==========================================
: square dup * ;      ( n -- )
: limit rot min max ; ( n lo hi -- n )
: odd 1 and logical ; ( n -- )
: even odd invert ;   ( n -- )
: nor or invert ;     ( u u -- u )
: nand and invert ;   ( u u -- u )
: bell 7 emit ;       ( -- )
: under >r dup r> ;   ( n1 n2 -- n1 n1 n2 )
: 2nip >r >r 2drop r> r> ; ( n1 n2 n3 n4 -- n3 n4 )
( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
: 2over >r >r 2dup r> swap >r swap r> r> -rot ;
: 2swap >r -rot r> -rot ; ( n1 n2 n3 n4 -- n3 n4 n1 n2 )
: 2tuck 2swap 2over ; ( n1 n2 n3 n4 -- n3 n4 n1 n2 n3 n4 )
: 4drop 2drop 2drop ; ( n1 n2 n3 n4 -- )
: trip dup dup ; ( n -- n n n )
\ ==== Extra Code 4/7 ==========================================
: log  >r 0 swap ( u base -- u )
  begin swap 1+ swap r@ / dup 0= until
  drop 1- rdrop ;
: log2 0 swap ( u -- u )
  begin swap 1+ swap   2/ dup 0= until
  drop 1- ;
: average um+ 2 um/mod nip ; ( u u -- u )
: <=> 2dup > if 2drop -1 exit then < ;
: bounds over + swap ;
: 2, , , ; ( n n -- )
: tab 9 emit ; ( -- )
: drup drop dup ; ( n1 n2 -- n1 n1 )
: lsb $ff and ; ( u -- u )
: --> 1 +block load ;
: scr blk ;
\ ==== Extra Code 5/7 ==========================================
: signum ( n -- -1 | 0 | 1 : Signum function )
  dup 0> if drop  1 exit then
      0< if      -1 exit then
      0 ;
: >< dup 8 rshift swap 8 lshift or ; ( u -- u : swap bytes )
: #digits dup 0= if 1+ exit then base @ log 1+ ;
: ** ( n u -- n )
  ?dup if
    over >r
    begin
      dup 1 >
    while
      swap r@ * swap 1-
    repeat rdrop drop
  else logical 1 and then ;
\ ==== Extra Code 6/7 ==========================================
: b. base @ swap 2 base ! u. base ! ; ( u -- )
: h. base @ swap hex u. base ! ;      ( u -- )
: o. base @ swap 8 base ! u. base ! ; ( u -- )
: d. base @ swap decimal . base ! ;   ( n -- )
: @bits swap @ and ;                  ( a u -- u )
: ?\ if [compile] \ then ; immediate
: ?( if [compile] ( then ; immediate ( )
: defined? ( -- pwd -1 | 0, <string> : is word defined? )
  bl word find if -1 else drop 0 then ;
: ?if compile dup [compile] if ; immediate
: ?dup-if compile ?dup [compile] if ; immediate
: >body ( dup @ $4000 or <> if 31 -throw then ) cell+ ;



\ ==== Extra Code 7/7 ==========================================
: screens ( k1 k2 -- : list blocks k1 to k2 )
	over -
	for
		dup . dup list 1+ nuf? if rdrop drop exit then
	next drop ;










\ ==== Roulette ================================================
\ Russian Roulette: It would be interesting to do something
\ killed the computer when the player dies

: click ."  *click*" cr ;
: bang  ."  BANG!" cr ;
: roulette random 6 mod if click else bang then ; ( -- )









\ ==== Extended ANSI Escape Codes ==============================
0 constant black 1 constant red 2 constant green 4 constant blue
red green        + constant yellow
    green blue   + constant cyan
red       blue   + constant magenta
red green blue + + constant white
: background $a + ;
: color $1e + sgr ;
\ : hide-cursor CSI [char] ? emit $19 10u. [char] l emit ;
\ : show-cursor CSI [char] ? emit $19 10u. [char] h emit ;
: up    [char] A ansi ; ( n -- )
: down  [char] B ansi ; ( n -- )
: left  [char] C ansi ; ( n -- )
: right [char] D ansi ; ( n -- )


\ ==== Screen Saver ============================================
\ An incredibly simple screen saver using ANSI Escape codes
\ for placement and coloring of random characters

: screen-saver ( -- )
  page
  begin
    random 80 mod
    random 40 mod at-xy
    random >char emit
    random 8  mod
    ( random 1 and if background then )
    color
  again ;


; ==== Game: YOU ARE DEAD (HELP) ===============================
This is a clone of the one dimensional rogue like game
available at <https://github.com/rupa/YOU_ARE_DEAD>. The
object is to get to the other side of the screen.

Keys:
w  Turn into '.'
a  Turn into '~'
s  Turn into '>'
d  Move right
q  Quit

Block number 7 is used to store the game state.




